<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,700|Source+Sans+Pro:300,700" rel="stylesheet">
    <link rel="stylesheet" href="../styling/style.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
    <script src="https://www.amcharts.com/lib/4/core.js"></script>
    <script src="https://www.amcharts.com/lib/4/charts.js"></script>
    <script src="../graphing/viz.js"></script>
    <title>Series Expansions</title>
</head>
<body>

<div class="row">
    <div class="col-md-8">
        <div class="header">Series Expansions</div>

        <p>
        If we wish to approximate an arbitrarily complex function but still be able to take accurate gradients, it's important that we can prove that
        our approximations have the same gradients as the original function. This way, we can use our approximation, which will be easier to calculate,
        and still have accurate gradients to pass to whichever optimization algorithm we're using.
        </p>

        <p>
        This goal of ours fits very well with Taylor and Maclaurin series expansions. These use derivatives to progressively make a local approxmation of
        a function more globally accurate. The Maclaurin series is simpler, as it begins its local approximation around \(x=0\).
        </p>

        <p>
        The simplest local approximation to an arbitrary differentiable function \(f(x)\) we could define would be \(L(x) = f(0)\). It's clear to see how
        this is centered around \(x=0\). To expand this approximation's accuracy, we'll also make the first derivative of the approximation equal the first
        derivative of the actual function at \(x=0\). We can do this with the following expression
        \[
        L(x) = f(0) + f'(0)x
        \]
        Notice how \(L'(x) = f'(0)\), which is exactly what we want. Now we'll make the second derivatives of our approxmation and original function equal
        as well with
        \[
        L(x) = f(0) + f'(0)x + \frac{1}{2}f''(0)x^2
        \]
        If adding the \(\frac{1}{2}\) and the \(x^2\) isn't intuitive, look at what happens when we differentiate our approximation now
        \[
        \begin{align*}
        L(x) &= f(0) + f'(0)x + \frac{1}{2}f''(0)x^2 \\
        L'(x) &= f'(0) + f''(0)x \\
        L''(x) &= f''(0)
        \end{align*}
        \]
        And if we evaluate them at \(x=0\) we get
        \[
        \begin{align*}
        L(0) &= f(0) \\
        L'(0) &= f'(0) \\
        L''(0) &= f''(0)
        \end{align*}
        \]
        This is exactly what we want, and we'll keep adding in higher-order derivatives in the same manner to make our approximation more accurate. If
        we add an infinite number of derivatives to our approximation like this, we'll end up with an approximation that equals our function at every point
        \[
        f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(0)}{n!} x^n
        \]
        </p>

        <p>
        Below is a series of finite Maclaurin series attempting to approximate \(f(x) = \sin x + \sin 2x - \cos x\). For notation, I consider an
        \(n\)th-order Maclaurin approximation to be the same as the formula above, except the sum only goes up to \(n\) instead of \(\infty\).
        Notice how the approximations become more accurate as \(n\) increases and that they are all at their most accurate around \(x=0\), as is expected.
        </p>
        <div id="maclaurin" style="height: 400px;"></div>

        <p>
        This approximation works well enough, but it'll take some time for it to become accurate for regions that are far away from \(x=0\). Since we can't
        actually compute infinite derivatives in real life, if we want our approximation to be accurate around a certain point for sure, we'll center
        our series of derivatives around that point. This generalization is what gives us the Taylor series
        \[
        f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(a)}{n!} (x-a)^n
        \]
        where \(a\) is the point around which our approximation is centered. If you do the math, you'll notice that the derivatives of this expression
        work out just as they did for the Maclaurin series if the function is evaluated at \(a\) instead of \(0\).
        </p>

        <p>
        Below are a few \(n\)th-order Taylor approximations to the same example
        \(f(x)\) as in the above graph. I've arbitrarily decided to use \(a = 2\) for this, and notice that the approximations are all most accurate
        now around the point \(x=2\)
        </p>

        <div id="taylor" style="height: 400px;"></div>
    </div>
</div>

<script>
function f(x) { return Math.sin(x) + Math.sin(2 * x) - Math.cos(x) }

function F(x, n) {
    sin = Math.sin;
    cos = Math.cos;

    t1 = 0;
    t2 = 0;
    t3 = 0;

    if (n % 2 == 0) {
        t1 = sin(x);
        t2 = sin(2 * x);
        t3 = cos(x);
    } else {
        t1 = cos(x);
        t2 = cos(2 * x);
        t3 = sin(x);
    }

    t2 *= Math.pow(2, n);

    if (Math.floor(n / 2) % 2 == 1) {
        t1 *= -1;
        t2 *= -1;
    }

    if (Math.floor((n + 1) / 2) % 2 == 0) {
        t3 *= -1;
    }

    return t1 + t2 + t3;
}

function factorial(x) {
    if (x == 0) return 1;
    return x * factorial(x - 1);
}

function g(x, n, c=0) {
    sum = 0;
    for (var i = 0; i <= n; i += 1) {
        sum += F(c, i) * Math.pow(x - c, i) / factorial(i);
    }
    return sum;
}

function t_0(x) { return g(x, 0, 2) }
function t_1(x) { return g(x, 1, 2) }
function t_2(x) { return g(x, 2, 2) }
function t_10(x) { return g(x, 10, 2) }

function m_0(x) { return g(x, 0) }
function m_1(x) { return g(x, 1) }
function m_2(x) { return g(x, 2) }
function m_10(x) { return g(x, 10) }

chart = newChart('maclaurin', true);
addFunctions(chart, [[f, 'f(x)'], [m_0, '0th', '#6FFEA5'], [m_1, '1st', '#72E9FF'], [m_2, '2nd', '#FFB5A5'], [m_10, '10th', '#FE6FC8']], -3, 3);

chart = newChart('taylor', true);
addFunctions(chart, [[f, 'f(x)'], [t_0, '0th', '#6FFEA5'], [t_1, '1st', '#72E9FF'], [t_2, '2nd', '#FFB5A5'], [t_10, '10th', '#FE6FC8']], -1, 5);
</script>

</body>
</html>
